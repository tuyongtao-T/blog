<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>javaScript 高级程序设计笔记 | 个人空间 </title>
    <meta name="generator" content="VuePress 1.5.2">
    <link rel="icon" href="./title.png">
    <meta name="description" content="一个基于Vuepress的个人博客">
    <link rel="preload" href="/assets/css/0.styles.309438b8.css" as="style"><link rel="preload" href="/assets/js/app.677c9ecd.js" as="script"><link rel="preload" href="/assets/js/2.e8c2162f.js" as="script"><link rel="preload" href="/assets/js/17.f8c13808.js" as="script"><link rel="prefetch" href="/assets/js/10.d1479605.js"><link rel="prefetch" href="/assets/js/11.9f40dd37.js"><link rel="prefetch" href="/assets/js/12.d4eb4066.js"><link rel="prefetch" href="/assets/js/13.38c74ed2.js"><link rel="prefetch" href="/assets/js/14.efd07d5d.js"><link rel="prefetch" href="/assets/js/15.bf252300.js"><link rel="prefetch" href="/assets/js/16.7089bb1f.js"><link rel="prefetch" href="/assets/js/18.1a9c9c0f.js"><link rel="prefetch" href="/assets/js/19.c8e6318e.js"><link rel="prefetch" href="/assets/js/20.11c6b14e.js"><link rel="prefetch" href="/assets/js/21.7e2bead1.js"><link rel="prefetch" href="/assets/js/22.ca69c1c6.js"><link rel="prefetch" href="/assets/js/23.cf01ac0d.js"><link rel="prefetch" href="/assets/js/24.aed16487.js"><link rel="prefetch" href="/assets/js/25.54d2c4f1.js"><link rel="prefetch" href="/assets/js/26.b757637e.js"><link rel="prefetch" href="/assets/js/27.52be87c3.js"><link rel="prefetch" href="/assets/js/28.43e583c0.js"><link rel="prefetch" href="/assets/js/29.b167b662.js"><link rel="prefetch" href="/assets/js/3.d1bfc316.js"><link rel="prefetch" href="/assets/js/30.950c8f15.js"><link rel="prefetch" href="/assets/js/4.53c9a2f9.js"><link rel="prefetch" href="/assets/js/5.07d1299c.js"><link rel="prefetch" href="/assets/js/6.ac008a4e.js"><link rel="prefetch" href="/assets/js/7.c1939fb7.js"><link rel="prefetch" href="/assets/js/8.8155eeb9.js"><link rel="prefetch" href="/assets/js/9.3706edaa.js">
    <link rel="stylesheet" href="/assets/css/0.styles.309438b8.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="./logo.png" alt="个人空间 " class="logo"> <span class="site-name can-hide">个人空间 </span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="学习笔记" class="dropdown-title"><span class="title">学习笔记</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/note/HTML/READEME.html" class="nav-link">
  HTML(5)
</a></li><li class="dropdown-item"><!----> <a href="/note/CSS/READEME.html" class="nav-link">
  CSS(3)
</a></li><li class="dropdown-item"><!----> <a href="/note/JavaScript/READEME.html" class="nav-link">
  javaScript
</a></li><li class="dropdown-item"><!----> <a href="/note/Vue/READEME.html" class="nav-link">
  Vue
</a></li><li class="dropdown-item"><!----> <a href="/note/Node/READEME.html" class="nav-link">
  Node.js
</a></li><li class="dropdown-item"><!----> <a href="/note/Git/READEME.html" class="nav-link">
  git
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="每日博文有感" class="dropdown-title"><span class="title">每日博文有感</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/thoughts/csdn/READEME.html" class="nav-link">
  CSDN
</a></li><li class="dropdown-item"><!----> <a href="/thoughts/juejin/READEME.html" class="nav-link">
  掘金
</a></li></ul></div></div><div class="nav-item"><a href="/note/Interview/READEME.html" class="nav-link">
  面试准备
</a></div><div class="nav-item"><a href="/component/" class="nav-link">
  组件
</a></div><div class="nav-item"><a href="https://github.com/tuyongtao-T?tab=repositories" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="https://gitee.com/tuyongtao" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Gitee
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="学习笔记" class="dropdown-title"><span class="title">学习笔记</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/note/HTML/READEME.html" class="nav-link">
  HTML(5)
</a></li><li class="dropdown-item"><!----> <a href="/note/CSS/READEME.html" class="nav-link">
  CSS(3)
</a></li><li class="dropdown-item"><!----> <a href="/note/JavaScript/READEME.html" class="nav-link">
  javaScript
</a></li><li class="dropdown-item"><!----> <a href="/note/Vue/READEME.html" class="nav-link">
  Vue
</a></li><li class="dropdown-item"><!----> <a href="/note/Node/READEME.html" class="nav-link">
  Node.js
</a></li><li class="dropdown-item"><!----> <a href="/note/Git/READEME.html" class="nav-link">
  git
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="每日博文有感" class="dropdown-title"><span class="title">每日博文有感</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/thoughts/csdn/READEME.html" class="nav-link">
  CSDN
</a></li><li class="dropdown-item"><!----> <a href="/thoughts/juejin/READEME.html" class="nav-link">
  掘金
</a></li></ul></div></div><div class="nav-item"><a href="/note/Interview/READEME.html" class="nav-link">
  面试准备
</a></div><div class="nav-item"><a href="/component/" class="nav-link">
  组件
</a></div><div class="nav-item"><a href="https://github.com/tuyongtao-T?tab=repositories" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="https://gitee.com/tuyongtao" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Gitee
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/note/JavaScript/READEME.html" class="sidebar-link">整体介绍</a></li><li><a href="/note/JavaScript/1.html" aria-current="page" class="active sidebar-link">javaScript 高级程序设计笔记</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/JavaScript/1.html#第一节-数据类型" class="sidebar-link">第一节 数据类型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/JavaScript/1.html#_1-1-null-undefined-和-boolean" class="sidebar-link">1.1 Null Undefined 和 Boolean</a></li><li class="sidebar-sub-header"><a href="/note/JavaScript/1.html#_1-2-number" class="sidebar-link">1.2 Number</a></li><li class="sidebar-sub-header"><a href="/note/JavaScript/1.html#_1-3-string" class="sidebar-link">1.3 String</a></li><li class="sidebar-sub-header"><a href="/note/JavaScript/1.html#_1-4-array" class="sidebar-link">1.4 Array</a></li><li class="sidebar-sub-header"><a href="/note/JavaScript/1.html#_1-5-object" class="sidebar-link">1.5 Object</a></li><li class="sidebar-sub-header"><a href="/note/JavaScript/1.html#_1-6-function" class="sidebar-link">1.6 Function</a></li><li class="sidebar-sub-header"><a href="/note/JavaScript/1.html#_1-7-regexp" class="sidebar-link">1.7 RegExp</a></li><li class="sidebar-sub-header"><a href="/note/JavaScript/1.html#_1-8-math" class="sidebar-link">1.8 Math</a></li><li class="sidebar-sub-header"><a href="/note/JavaScript/1.html#_1-9-date" class="sidebar-link">1.9 Date</a></li><li class="sidebar-sub-header"><a href="/note/JavaScript/1.html#_2-0-json" class="sidebar-link">2.0 JSON</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/JavaScript/1.html#第二节" class="sidebar-link">第二节</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/JavaScript/1.html#_1-3" class="sidebar-link">1.3</a></li><li class="sidebar-sub-header"><a href="/note/JavaScript/1.html#_1-2" class="sidebar-link">1.2</a></li><li class="sidebar-sub-header"><a href="/note/JavaScript/1.html#_1-3-2" class="sidebar-link">1.3</a></li><li class="sidebar-sub-header"><a href="/note/JavaScript/1.html#_1-2-2" class="sidebar-link">1.2</a></li><li class="sidebar-sub-header"><a href="/note/JavaScript/1.html#_1-3-3" class="sidebar-link">1.3</a></li><li class="sidebar-sub-header"><a href="/note/JavaScript/1.html#_1-2-3" class="sidebar-link">1.2</a></li><li class="sidebar-sub-header"><a href="/note/JavaScript/1.html#_1-3-4" class="sidebar-link">1.3</a></li></ul></li></ul></li><li><a href="/note/JavaScript/2.html" class="sidebar-link">ES6学习笔记</a></li><li><a href="/note/JavaScript/3.html" class="sidebar-link">JavaScript性能</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="javascript-高级程序设计笔记"><a href="#javascript-高级程序设计笔记" class="header-anchor">#</a> javaScript 高级程序设计笔记</h1> <h2 id="第一节-数据类型"><a href="#第一节-数据类型" class="header-anchor">#</a> 第一节 数据类型</h2> <p>javascript目前一共有7种数据类型，分为基本数据类型和引用数据类型。
<strong>基本数据类型包括</strong>：Null Undefined Boolean Number String / BigInt——<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/BigInt" target="_blank" rel="noopener noreferrer">MDN<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> <strong>引用类型</strong>： 广义的来说是Object,其中包括 狭义object Array Function
<strong>ES6的</strong>： Symbol 类型</p> <h4 id="说到类型，我们首先学习判断数据类型的方法："><a href="#说到类型，我们首先学习判断数据类型的方法：" class="header-anchor">#</a> 说到类型，我们首先学习判断数据类型的方法：</h4> <ul><li><p>typeof： 粗略判断 typeof a</p></li> <li><p>instanceof: 稍微精确判断 用法 a instanceof Array，返回的是true或false</p></li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>原理：   a._proto_ 是否是 Array.prototype 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li>Object.prototype.toString: 准确判断   Object.prototype.toString.call(a)  返回的是 [object Array]  可以转为直接返回类型字符串。 <a href="http://hello2dj.com/2018/04/05/fix-typeof/" target="_blank" rel="noopener noreferrer">参考链接<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>const toType = function(obj) {
  return ({}).toString.call(obj).match(/\s([a-zA-Z]+)/)[1];
  // 不同的正则表达式
  return ({}).toString.call(obj).match(/\[object (.*?)\]/)[1].toLowerCase();
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="_1-1-null-undefined-和-boolean"><a href="#_1-1-null-undefined-和-boolean" class="header-anchor">#</a> 1.1 Null Undefined 和 Boolean</h3> <p>这里需要注意的是 Null在转为Boolean时为 0 ；undefined转为boolean时为 NaN;</p> <p>boolean 类型中： 除了 null undefined  0  false NaN  空字符串（''）,其余都为true</p> <h3 id="_1-2-number"><a href="#_1-2-number" class="header-anchor">#</a> 1.2 Number</h3> <p>javascript内部，所有数字都是以64位浮点数形式存储，所以1和1.0是相同的，小数运算时要特别小心。
JavaScript能表示的数值范围在2<sup>1024</sup>到2<sup>-1024</sup>之间，超出后为Infinity和0。</p> <h4 id="关于-0-和-0："><a href="#关于-0-和-0：" class="header-anchor">#</a> 关于+0 和-0：</h4> <p>这里说到 === 和 ==  和 Object.is(a,b)
== 会自动转为数据类型比较；=== 中NaN不等于NaN,+0等于-0；Object.is()中，NaN等于NaN,+0不等于-0</p> <h4 id="与数值相关的全局方法"><a href="#与数值相关的全局方法" class="header-anchor">#</a> 与数值相关的全局方法</h4> <ul><li>parseInt(a,b)  parseFloat(a,b)   Number(a,b),a为传入的字符串，b为转换的进制数。一般常用的是parseInt()。</li> <li>isNaN() 用来判断一个值是否为NaN。 isNaN(a)</li> <li>isFinite() 用来判断一个值是否为正常的数值(有限)。isFinite(a)</li></ul> <h4 id="number对象"><a href="#number对象" class="header-anchor">#</a> Number对象</h4> <p>Number对象是数值对应的包装对象，可以作为构造函数使用，也可以作为工具函数使用。作为构造函数时，它用于生成值为数值的对象。</p> <h4 id="实例方法"><a href="#实例方法" class="header-anchor">#</a> 实例方法</h4> <ul><li><p>Number.prototype.toString()， 用来将一个数值转为字符串形式</p></li> <li><div class="language- line-numbers-mode"><pre class="language-text"><code>(10).toString(b) // &quot;10&quot; b为进制数，默认为10进制
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li> <li><p>Number.prototype.toFixed(b)，将一个数转为指定位数的小数，然后返回这个小数对应的字符串</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>(10).toFixed(2) // &quot;10.00&quot;
10.005.toFixed(2) // &quot;10.01&quot;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li> <li><p>Number.prototype.toExponential(b),将一个数转为科学计数法形式</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>(10).toExponential()  // &quot;1e+1&quot;
(10).toExponential(1) // &quot;1.0e+1&quot;
(10).toExponential(2) // &quot;1.00e+1&quot;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></li></ul> <h4 id="es6补充模块"><a href="#es6补充模块" class="header-anchor">#</a> ES6补充模块</h4> <ul><li>ES6 将全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变。<strong>这样做的目的，是逐步减少全局性方法，使得语言逐步模块化。</strong></li> <li>ES6 在Number对象上，新提供了Number.isFinite()和Number.isNaN()两个方法。
Number.isFinite() 用来检查一个数值是否为有限的（finite），即不是Infinity。</li> <li>Number.isInteger() 用来判断一个数值是否为整数</li></ul> <h3 id="_1-3-string"><a href="#_1-3-string" class="header-anchor">#</a> 1.3 String</h3> <h4 id="字符串与数组"><a href="#字符串与数组" class="header-anchor">#</a> 字符串与数组</h4> <p>字符串可以被视为字符数组，因此可以使用数组的方括号运算符，用来返回某个位置的字符,同时具有length属性。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  var s = 'hello';
  s[0] // &quot;h&quot;
  s[1] // &quot;e&quot;
  s[4] // &quot;o&quot;

  // 直接对字符串使用方括号运算符
  'hello'[1] // &quot;e&quot;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h4 id="字符串对象"><a href="#字符串对象" class="header-anchor">#</a> 字符串对象</h4> <h4 id="实例方法-2"><a href="#实例方法-2" class="header-anchor">#</a> 实例方法</h4> <ul><li>String.prototype.charAt(index)  String.prototype.charCodeAt(index)</li> <li>String.prototype.concat(str) 这里字符串连接用'+'的性能比concat()好</li> <li>String.prototype.slice(a,b) 和String.prototype.substring(a,b) 和 String.prototype.substr(a,b) ：a都表示子串的起始位置，前两个的b表示结束的位置（后一位），默认为最后一个；最后一个b表示截取的字符长度。</li> <li>String.prototype.indexOf(str,b)，String.prototype.lastIndexOf(str,b) :用于确定一个字符串在另一个字符串中第一次出现的位置，返回结果是匹配开始的位置。如果返回-1，就表示不匹配。</li> <li>String.prototype.trim() -- String.prototype.trimLeft(),String.prototype.trimRight() [兼容性]</li> <li>String.prototype.toLowerCase()，String.prototype.toUpperCase()</li> <li>String.prototype.match() 用于确定原字符串是否匹配某个子字符串，返回一个数组，成员为匹配的第一个字符串,如果没有找到匹配，则返回null</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code> var matches = 'cat, bat, sat, fat'.match('at');
 matches.index // 1
 matches.input // &quot;cat, bat, sat, fat&quot;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ul><li><p>String.prototype.search()，String.prototype.replace() search方法的用法基本等同于match，但是返回值为匹配的第一个位置。如果没有找到匹配，则返回-1。replace方法用于替换匹配的子字符串，一般情况下只替换第一个匹配（除非使用带有g修饰符的正则表达式）。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>'aaa'.replace('a', 'b') // &quot;baa&quot;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li> <li><p>String.prototype.split()</p></li> <li><p>String.prototype.localeCompare() 用于比较两个字符串。它返回一个整数，如果小于0，表示第一个字符串小于第二个字符串；如果等于0，表示两者相等；如果大于0，表示第一个字符串大于第二个字符串。</p></li></ul> <h4 id="es6扩展"><a href="#es6扩展" class="header-anchor">#</a> ES6扩展</h4> <ul><li>字符串的遍历器接口：ES6 为字符串添加了遍历器接口（Iterator），使得字符串可以被for...of循环遍历。</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>for (let codePoint of 'foo') {
  console.log(codePoint)
}
// &quot;f&quot;
// &quot;o&quot;
// &quot;o&quot;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><ul><li>模板字符串 ： <code>str ${}</code> =&gt; 模板字符串中嵌入变量，需要将变量名写在${}之中。</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code> `Hello ${'World'}`
 // &quot;Hello World&quot;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><ul><li><p>字符串ES6新增方法</p> <ul><li>includes()：返回布尔值，表示是否找到了参数字符串。</li> <li>startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。</li> <li>endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。 这三个方法都支持第二个参数，表示开始搜索的位置。</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>let s = 'Hello world!';

s.startsWith('world', 6) // true
s.endsWith('Hello', 5) // true
s.includes('Hello', 6) // false
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ul><li>repeat():返回一个新字符串，表示将原字符串重复n次。</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>'x'.repeat(3) // &quot;xxx&quot;
'hello'.repeat(2) // &quot;hellohello&quot;
'na'.repeat(0) // &quot;&quot;  
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ul><li>padStart()，padEnd() ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>  'x'.padStart(5, 'ab') // 'ababx'
  'x'.padStart(4, 'ab') // 'abax'

  'x'.padEnd(5, 'ab') // 'xabab'
  'x'.padEnd(4, 'ab') // 'xaba'
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ul><li>trimStart()，trimEnd() ES2019 对字符串实例新增了trimStart()和trimEnd()这两个方法。它们的行为与trim()一致，trimStart()消除字符串头部的空格，trimEnd()消除尾部的空格。它们返回的都是新字符串，不会修改原始字符串。</li></ul></li></ul> <h3 id="_1-4-array"><a href="#_1-4-array" class="header-anchor">#</a> 1.4 Array</h3> <p>判断是否是数组: Array.isArray([ ])
将类数组转为真正的数组：</p> <ul><li>Array.prototype.slice.call(arrayLike);</li> <li>Array.from(a)</li></ul> <h4 id="for-in-循环和数组的遍历"><a href="#for-in-循环和数组的遍历" class="header-anchor">#</a> for...in 循环和数组的遍历</h4> <p>for...in循环不仅可以遍历对象，也可以遍历数组，毕竟数组只是一种特殊对象。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  var a = [1, 2, 3];
  for (var i in a) {
    console.log(a[i]);
  }
  // 1
  // 2
  // 3
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h4 id="实例方法-3"><a href="#实例方法-3" class="header-anchor">#</a> 实例方法</h4> <ol><li>valueOf()，toString()：不同对象的valueOf方法不尽一致，数组的valueOf方法返回数组本身。数组的toString方法返回数组的字符串形式</li></ol> <div class="language- line-numbers-mode"><pre class="language-text"><code>  var arr = [1, 2, 3];
  arr.valueOf() // [1, 2, 3]
  /* */
  var arr = [1, 2, 3];
  arr.toString() // &quot;1,2,3&quot;

  var arr = [1, 2, 3, [4, 5, 6]];
  arr.toString() // &quot;1,2,3,4,5,6&quot;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><ol start="2"><li>栈方法和队列方法：
push()，pop() /  shift()，unshift()</li> <li>连接方法： join()方法以指定参数作为分隔符，将所有数组成员连接为一个字符串返回。如果不提供参数，默认用逗号分隔。 <strong>concat()</strong>： concat方法用于多个数组的合并</li></ol> <div class="language- line-numbers-mode"><pre class="language-text"><code>  var a = [1, 2, 3, 4];
  a.join(' ') // '1 2 3 4'
  a.join(' | ') // &quot;1 | 2 | 3 | 4&quot;
  a.join() // &quot;1,2,3,4&quot;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ol start="4"><li>数组元素倒序：  reverse()，该方法将改变原数组</li> <li>截取数组一部分： slice()</li></ol> <div class="language- line-numbers-mode"><pre class="language-text"><code>arr.slice(start, end);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ol start="6"><li>数组的增删改查：splice()
arr.splice(start, count, addElement1, addElement2, ...);
splice的第一个参数是删除的起始位置（从0开始），第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。</li> <li>排序：sort()： sort方法对数组成员进行排序，默认是按照字典顺序排序</li></ol> <div class="language- line-numbers-mode"><pre class="language-text"><code>var arr = [2,5,1,4,68,0]
arr.sort((a,b) =&gt; a-b)//利用箭头函数
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><ol start="8"><li>遍历： 缺点，不能通过break来停止
<ul><li>map() :有返回值</li> <li>forEach() : 没有返回值</li> <li>some() : 有一个 true，就返回true</li> <li>every() ： 所有的都为true，才返回true</li> <li>filter()： 过滤数组成员，返回满足条件的成员组成的新数组
<strong>每个方法接收两个参数：要在每一项上运行的函数 和 this，绑定参数函数内部的this变量</strong>
callack(): 包含三个参数，（item,index,arr）</li></ul></li> <li>归并方法： reduce()，reduceRight():reduce方法和reduceRight方法依次处理数组的每个成员，最终累计为一个值</li></ol> <div class="language- line-numbers-mode"><pre class="language-text"><code>  [1, 2, 3, 4, 5].reduce(function (a, b) {
    console.log(a, b);
    return a + b;
  })
  // 1 2
  // 3 3
  // 6 4
  // 10 5
  //最后结果：15
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h4 id="es6扩展-2"><a href="#es6扩展-2" class="header-anchor">#</a> ES6扩展</h4> <h4 id="扩展运算符"><a href="#扩展运算符" class="header-anchor">#</a> 扩展运算符</h4> <ol><li>扩展运算符（spread）是三个点（...）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。</li></ol> <div class="language- line-numbers-mode"><pre class="language-text"><code>console.log(...[1, 2, 3])
// 1 2 3

console.log(1, ...[2, 3, 4], 5)
// 1 2 3 4 5

[...document.querySelectorAll('div')]
// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><ol start="2"><li><strong>补充:</strong> 将字符串转为数组的三个方法：</li></ol> <div class="language- line-numbers-mode"><pre class="language-text"><code>Array.from();
str.split('');
[...str]
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Array.from(arrayLike, x =&gt; x * x);
// 等同于
Array.from(arrayLike).map(x =&gt; x * x);

Array.from([1, 2, 3], (x) =&gt; x * x)
// [1, 4, 9]
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><ol start="3"><li>Array.of():用于将一组值，转换为数组</li></ol> <div class="language- line-numbers-mode"><pre class="language-text"><code>Array.of(3, 11, 8) // [3,11,8]
Array.of(3) // [3]
Array.of(3).length // 1
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ol start="4"><li>find() 和 findIndex(): 用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。两个方法接受第二个参数，用来绑定回调函数的this对象。</li></ol> <div class="language- line-numbers-mode"><pre class="language-text"><code>[1, 4, -5, 10].find((n) =&gt; n &lt; 0)
// -5

[1, 5, 10, 15].find(function(value, index, arr) {
  return value &gt; 9;
}) // 10
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><ol start="5"><li>fill()： 使用给定值，填充一个数组</li></ol> <div class="language- line-numbers-mode"><pre class="language-text"><code>  ['a', 'b', 'c'].fill(7, 1, 2)
  // ['a', 7, 'c']
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><ol start="6"><li>数组实例的 entries()，keys() 和 values(): 如果不使用for...of循环，可以手动调用遍历器对象的next方法，进行遍历</li></ol> <div class="language- line-numbers-mode"><pre class="language-text"><code>  let letter = ['a', 'b', 'c'];
  let entries = letter.entries();
  console.log(entries.next().value); // [0, 'a']
  console.log(entries.next().value); // [1, 'b']
  console.log(entries.next().value); // [2, 'c']
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ol start="7"><li>includes() :方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。</li></ol> <h3 id="_1-5-object"><a href="#_1-5-object" class="header-anchor">#</a> 1.5 Object</h3> <p>什么是对象？简单来说就是一组&quot;键值对&quot;（key-value）的集合，是一种无序的符合数据的集合。</p> <h4 id="属性的查看"><a href="#属性的查看" class="header-anchor">#</a> 属性的查看</h4> <p><strong>Object.keys(obj)</strong>:查看对象本身的所有属性</p> <p><strong>in运算符</strong>：检查对象是否包含某个属性，它不能识别哪些属性是对象自身的，哪些属性是继承的</p> <h4 id="属性的遍历：for-in-循环"><a href="#属性的遍历：for-in-循环" class="header-anchor">#</a> 属性的遍历：for...in 循环</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>  var obj = {a: 1, b: 2, c: 3};

  for (var i in obj) {
    console.log('键名：', i);
    console.log('键值：', obj[i]);
  }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>它遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性。
它不仅遍历对象自身的属性，还遍历继承的属性。</p> <h4 id="object对象"><a href="#object对象" class="header-anchor">#</a> Object对象</h4> <p>Object对象的原生方法分成两类：Object本身的方法与Object的实例方法</p> <p><strong>本身方法</strong>：直接定义在对象上的方法</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  Object.print = function (o) { console.log(o) };
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>实例方法</strong>：定义在Object原型对象Object.prototype上的方法。它可以被Object实例直接使用。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  Object.prototype.print = function () {
    console.log(this);
  };

  var obj = new Object();
  obj.print() // Object
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>全局方法：Object()：将任意值转为对象。这个方法常用于保证某个值一定是对象。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  var obj = Object();
  // 等同于
  var obj = Object(undefined);
  var obj = Object(null);

  obj instanceof Object // true
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h4 id="object-的静态方法"><a href="#object-的静态方法" class="header-anchor">#</a> Object 的静态方法</h4> <ul><li>Object.keys(obj)和Object.getOwnPropertyNames(obj): 接收一个对象作为参数，返回该对象所有自身属性组成的数组，其中Object.getOwnPropertyNames(obj)还返回不可枚举的属性名</li> <li>对象属性相关的方法：
<ul><li>Object.getOwnPropertyDescriptor(obj,prop): 获取描述某个属性的对象(自身属性)</li> <li>Object.getOwnPropertyDescriptors(obj): 获取描述对象所有属性的描述对象(自身属性)</li> <li>Object.defineProperty(obj,prop,descriptor): 通过descriptor，定义某个属性的描述</li> <li>Object.defineProperties(obj,descriptors)：通过描述对象，定义多个属性的描述对象。</li></ul></li> <li>控制对象状态相关的方法：<a href="https://wangdoc.com/javascript/stdlib/object.html#%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95" target="_blank" rel="noopener noreferrer">参考<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> <ul><li>Object.freeze(obj)：冻结一个对象。</li> <li>Object.isFrozen(obj)：判断一个对象是否被冻结。</li></ul></li> <li>原型链相关方法：
<ul><li>Object.create(obj,props)：该方法可以指定原型对象和属性，返回一个新的对象。</li> <li>Object.getPrototypeOf(obj)：获取对象的Prototype（原型）对象。</li></ul></li></ul> <h4 id="object-的实例方法"><a href="#object-的实例方法" class="header-anchor">#</a> Object 的实例方法</h4> <ul><li>Object.prototype.valueOf()：返回当前对象对应的值。</li> <li>Object.prototype.toString()：返回当前对象对应的字符串形式。</li> <li>Object.prototype.toLocaleString()：返回当前对象对应的本地字符串形式。</li> <li>Object.prototype.hasOwnProperty(prop)：判断某个属性是否为当前对象自身的属性，还是继承自原型对象的属性。<div class="language- line-numbers-mode"><pre class="language-text"><code>  var obj = {
    p: 123
  };

  obj.hasOwnProperty('p') // true
  obj.hasOwnProperty('toString') // false
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div></li> <li>Object.prototype.isPrototypeOf()：判断当前对象是否为另一个对象的原型。<div class="language- line-numbers-mode"><pre class="language-text"><code>  var obj= {
  			name: 'tyt',
  		}
  var obj2= { };
  bj2.__proto__ = obj; 
  obj.isPrototypeOf(obj2); //true
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div></li> <li>Object.prototype.propertyIsEnumerable(prop)：判断某个属性是否可枚举。</li></ul> <h4 id="es6补充模块-2"><a href="#es6补充模块-2" class="header-anchor">#</a> ES6补充模块</h4> <p><strong>全局方法</strong></p> <p>Object.assign():用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  const target = { a: 1 };

  const source1 = { b: 2 };
  const source2 = { c: 3 };

  Object.assign(target, source1, source2);
  target // {a:1, b:2, c:3}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>Object.assign()方法实行的是浅拷贝，就是说如果源对象某个属性的值是对象，那么目标对象拷贝到的是这个对象的引用，但他无法正确拷贝get属性和set属性。</p></div> <p><strong>应用</strong>：对数组的处理<a href="https://wangdoc.com/es6/object-methods.html#objectis" target="_blank" rel="noopener noreferrer">参考<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  Object.assign([1, 2, 3], [4, 5])
  // [4, 5, 3]
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Object.assign()把数组视为属性名为 0、1、2 的对象，因此源数组的 0 号属性4覆盖了目标数组的 0 号属性1。</p> <h5 id="proto-属性，object-setprototypeof-，object-getprototypeof"><a href="#proto-属性，object-setprototypeof-，object-getprototypeof" class="header-anchor">#</a> __proto__属性，Object.setPrototypeOf()，Object.getPrototypeOf()</h5> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>JavaScript 语言的对象继承是通过原型链实现的。ES6 提供了更多原型对象的操作方法.
__proto__属性没有写入 ES6 的正文，而是写入了附录，原因是__proto__前后的双下划线，说明它本质上是一个内部属性，而不是一个正式的对外的 API，只是由于浏览器广泛支持，才被加入了 ES6。标准明确规定，只有浏览器必须部署这个属性，其他运行环境不一定需要部署，而且新的代码最好认为这个属性是不存在的。因此，无论从语义的角度，还是从兼容性的角度，都不要使用这个属性，而是使用下面的Object.setPrototypeOf()（写操作）、Object.getPrototypeOf()（读操作）、Object.create()（生成操作）代替。</p></div> <ul><li><strong>proto</strong>: 用来读取或设置当前对象的原型对象（prototype）<div class="language- line-numbers-mode"><pre class="language-text"><code>  // es5 的写法
  const obj = {
    method: function() { ... }
  };
  obj.__proto__ = someOtherObj;

  // es6 的写法
  var obj = Object.create(someOtherObj);
  obj.method = function() { ... };
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div></li> <li>Object.setPrototypeOf(obj,prototype): 作用与__proto__相同，用来设置一个对象的原型对象（prototype），返回参数对象本身。它是 ES6 正式推荐的设置原型对象的方法。<div class="language- line-numbers-mode"><pre class="language-text"><code>  let proto = {};
  let obj = { x: 10 };
  Object.setPrototypeOf(obj, proto);

  proto.y = 20;
  proto.z = 40;

  obj.x // 10
  obj.y // 20
  obj.z // 40
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div></li> <li>Object.keys(obj)，Object.values(obj)，Object.entries(obj):都返回一个数组，成员分别是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名、键值、键值对数组。</li></ul> <h4 id="属性描述对象-attributes-object参考"><a href="#属性描述对象-attributes-object参考" class="header-anchor">#</a> 属性描述对象—— attributes object<a href="https://wangdoc.com/javascript/stdlib/attributes.html#%E6%A6%82%E8%BF%B0" target="_blank" rel="noopener noreferrer">参考<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h4> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>JavaScript 提供了一个内部数据结构，用来描述对象的属性，控制它的行为，比如该属性是否可写、可遍历等等。这个内部数据结构称为“属性描述对象”（attributes object）。每个属性都有自己对应的属性描述对象，保存该属性的一些元信息。</p></div> <div class="language- line-numbers-mode"><pre class="language-text"><code>  {
    value: 123,
    writable: false,
    enumerable: true,
    configurable: false,
    get: undefined,
    set: undefined
  }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><ol><li>value: 该属性的属性值，默认为undefined</li> <li>writable: 该属性是否可写，默认为true</li> <li>enumberable: 该属性是否可遍历，默认为true</li> <li>configurable：表示可配置性，默认为true；configurable属性控制了属性描述对象的可写性</li> <li>get: get是一个函数，表示该属性的取值函数（getter）,默认为undefined</li> <li>set：set是一个函数，表示该属性的存值函数（setter），默认为undefined</li></ol> <h4 id="存取器"><a href="#存取器" class="header-anchor">#</a> 存取器</h4> <p>除了直接定义以外，属性还可以用存取器（accessor）定义。其中，存值函数称为setter，使用属性描述对象的set属性；取值函数称为getter，使用属性描述对象的get属性。
一旦对目标属性定义了存取器，那么存取的时候，都将执行对应的函数。利用这个功能，可以实现许多高级特性，比如定制属性的读取和赋值行为。</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>注意，取值函数get不能接受参数，存值函数set只能接受一个参数（即属性的值）。</p></div> <div class="language- line-numbers-mode"><pre class="language-text"><code>  var obj = {
    get p() {
      return 'getter';
    },
    set p(value) {
      console.log('setter: ' + value);
    }
  };
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h4 id="控制对象状态"><a href="#控制对象状态" class="header-anchor">#</a> 控制对象状态</h4> <p>有时需要冻结对象的读写状态，防止对象被改变。JavaScript 提供了三种冻结方法，最弱的一种是Object.preventExtensions()，其次是Object.seal()，最强的是Object.freeze()</p> <h3 id="_1-6-function"><a href="#_1-6-function" class="header-anchor">#</a> 1.6 Function</h3> <p><strong>函数名的提升</strong>：下面例子中，表面上后面声明的函数f，应该覆盖前面的var赋值语句，但是由于存在函数提升，实际上正好反过来。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  var f = function () {
    console.log('1');
  }

  function f() {
    console.log('2');
  }

  f() // 1
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h4 id="函数的属性和方法"><a href="#函数的属性和方法" class="header-anchor">#</a> 函数的属性和方法</h4> <ul><li>length: 返回定义时预传入的参数个数</li> <li>toString()： 返回的是函数的源码</li> <li>arguments和this：arguments是一个类数组对象，保存着传入的函数参数，该对象有一个callee属性，它是一个指针，指向拥有arguments对象的函数；他还是有一个caller属性，保存着调用当前函数的函数的引用。this引用的是函数执行时的环境对象，</li> <li>每个函数都包含两个非继承而来的方法： call（scope,str） 和apply（scope,arr）。这两个方法用途都是在特定的作用域中调用函数，实际上就是设置函数体内部this的值。</li></ul> <h4 id="函数作用域（scope）"><a href="#函数作用域（scope）" class="header-anchor">#</a> 函数作用域（scope）</h4> <p>javascript中的作用域有： 全局作用域对应全局变量，变量在整个程序中一直存在，所有地方都可以读取；函数作用域对应局部变量，变量只在函数内部存在；ES6的块级作用域。</p> <h4 id="函数本身的作用域"><a href="#函数本身的作用域" class="header-anchor">#</a> 函数本身的作用域</h4> <p><strong>函数本身也是一个值</strong>，也有自己的作用域。它的作用域与变量一样，就是其声明时所在的作用域，与其运行时所在的作用域无关。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  var a = 1;
  var x = function () {
    console.log(a);
  };

  function f() {
    var a = 2;
    x();
  }

f() // 1
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>同样的，函数体内部声明的函数，作用域绑定函数体内部。函数foo内部声明了一个函数bar，bar的作用域绑定foo。当我们在foo外部取出bar执行时，变量x指向的是foo内部的x，而不是foo外部的x。正是这种机制，构成了下文要讲解的“闭包”现象。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  function foo() {
    var x = 1;
    function bar() {
      console.log(x);
    }
    return bar;
  }

  var x = 2;
  var f = foo();
  f() // 1
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h4 id="闭包-保存和保护作用"><a href="#闭包-保存和保护作用" class="header-anchor">#</a> 闭包: 保存和保护作用</h4> <p>由于在 JavaScript 语言中，只有函数内部的子函数才能读取内部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。闭包最大的特点，就是它可以“记住”诞生的环境，比如f2记住了它诞生的环境f1，所以从f2可以得到f1的内部变量。在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。
闭包的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在。请看下面的例子，闭包使得内部变量记住上一次调用时的运算结果。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  function createIncrementor(start) {
    return function () {
      return start++;
    };
  }

  var inc = createIncrementor(5);

  inc() // 5
  inc() // 6
  inc() // 7
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>为什么会这样呢？原因就在于inc始终在内存中，而inc的存在依赖于createIncrementor()，因此也始终在内存中，不会在调用结束后，被垃圾回收机制回收</p> <p><strong>封装对象的私有属性和私有方法</strong></p> <h4 id="es6补充模块-3"><a href="#es6补充模块-3" class="header-anchor">#</a> ES6补充模块</h4> <p>参数默认值: 注意，在制定了参数默认值后，函数的length属性将失效
<strong>箭头函数</strong>
ES6 允许使用“箭头”（=&gt;）定义函数。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  var f = () =&gt; 5;
  // 等同于
  var f = function () { return 5 };

  var sum = (num1, num2) =&gt; num1 + num2;
  // 等同于
  var sum = function(num1, num2) {
    return num1 + num2;
  };
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>注意事项:</p> <ul><li>箭头函数内部的this是定义时所在的对象（环境），而不是执行时所在的对象，这与普通函数是相反的</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>  function Timer() {
    this.s1 = 0;
    this.s2 = 0;
    // 箭头函数
    setInterval(() =&gt; this.s1++, 1000);
    // 普通函数
    setInterval(function () {
      this.s2++;
    }, 1000);
  }

  var timer = new Timer();

  setTimeout(() =&gt; console.log('s1: ', timer.s1), 3100); // 3
  setTimeout(() =&gt; console.log('s2: ', timer.s2), 3100); // 0
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><ul><li>不存在argumengs对象，他用rest参数替代</li> <li>不可以使用yield命令，因此箭头函数不能用作 Generator 函数
不适合应用箭头函数的场合：定义对象的方法，且该方法内部包括this；需要动态this的时候，也不应使用箭头函数</li></ul> <h4 id="尾调用优化-：-节省内存-参考"><a href="#尾调用优化-：-节省内存-参考" class="header-anchor">#</a> 尾调用优化 ： 节省内存 <a href="https://juejin.im/post/6844903590033621006" target="_blank" rel="noopener noreferrer">参考<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h4> <p>尾调用是函数式编程的重要概念，指某个函数的最后一步是调用另一个函数,即最后一步总是 <strong>return fun（）</strong>；</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  function f(x){
    return g(x);
  }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h4 id="尾递归：-参考"><a href="#尾递归：-参考" class="header-anchor">#</a> 尾递归： <a href="https://wangdoc.com/es6/function.html#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC" target="_blank" rel="noopener noreferrer">参考<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h4> <p>递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  function factorial(n) {
    if (n === 1) return 1;
    return n * factorial(n - 1);
  }

  factorial(5) // 120
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) 。
如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  function factorial(n, total) {
    if (n === 1) return total;
    return factorial(n - 1, n * total);
  }

  factorial(5, 1) // 120
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>非尾递归的 Fibonacci 数列实现如下:</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  function Fibonacci (n) {
    if ( n &lt;= 1 ) {return 1};

    return Fibonacci(n - 1) + Fibonacci(n - 2);
  }

  Fibonacci(10) // 89
  Fibonacci(100) // 超时
  Fibonacci(500) // 超时
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>尾递归优化过的 Fibonacci 数列实现如下:</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  function Fibonacci2 (n , ac1 = 1 , ac2 = 1) {
    if( n &lt;= 1 ) {return ac2};

    return Fibonacci2 (n - 1, ac2, ac1 + ac2);
  }

  Fibonacci2(100) // 573147844013817200000
  Fibonacci2(1000) // 7.0330367711422765e+208
  Fibonacci2(10000) // Infinity
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h4 id="递归函数的改写：-一旦使用递归，就最好使用尾递归。"><a href="#递归函数的改写：-一旦使用递归，就最好使用尾递归。" class="header-anchor">#</a> 递归函数的改写： 一旦使用递归，就最好使用尾递归。</h4> <p>尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。比如上面的例子，阶乘函数 factorial 需要用到一个中间变量total，那就把这个中间变量改写成函数的参数。这样做的缺点就是不太直观</p> <p>两个方法可以解决这个问题。方法一是在尾递归函数之外，再提供一个正常形式的函数</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  function tailFactorial(n, total) {
    if (n === 1) return total;
    return tailFactorial(n - 1, n * total);
  }

  function factorial(n) {
    return tailFactorial(n, 1);
  }

  factorial(5) // 120
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>函数式编程有一个概念，叫做柯里化（currying），意思是将多参数的函数转换成单参数的形式。这里也可以使用柯里化.</p> <p>第二种方法就简单多了，就是采用 ES6 的函数默认值</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  function factorial(n, total = 1) {
    if (n === 1) return total;
    return factorial(n - 1, n * total);
  }

  factorial(5) // 120
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="_1-7-regexp"><a href="#_1-7-regexp" class="header-anchor">#</a> 1.7 RegExp</h3> <p><a href="https://wangdoc.com/javascript/stdlib/regexp.html#%E6%A6%82%E8%BF%B0" target="_blank" rel="noopener noreferrer">参考<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>
正则表达式（regular expression）是一种表达文本模式（即字符串结构）的方法，有点像字符串的模板，常常用来按照“给定模式”匹配文本</p> <h3 id="_1-8-math"><a href="#_1-8-math" class="header-anchor">#</a> 1.8 Math</h3> <p><a href="https://wangdoc.com/javascript/stdlib/math.html#%E9%9D%99%E6%80%81%E5%B1%9E%E6%80%A7" target="_blank" rel="noopener noreferrer">参考1<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://wangdoc.com/es6/number.html#math-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95" target="_blank" rel="noopener noreferrer">参考2<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="_1-9-date"><a href="#_1-9-date" class="header-anchor">#</a> 1.9 Date</h3> <p><a href="https://wangdoc.com/javascript/stdlib/date.html" target="_blank" rel="noopener noreferrer">参考<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="_2-0-json"><a href="#_2-0-json" class="header-anchor">#</a> 2.0 JSON</h3> <p><a href="https://wangdoc.com/javascript/stdlib/json.html" target="_blank" rel="noopener noreferrer">参考<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="第二节"><a href="#第二节" class="header-anchor">#</a> 第二节</h2> <h3 id="_1-3"><a href="#_1-3" class="header-anchor">#</a> 1.3</h3> <h3 id="_1-2"><a href="#_1-2" class="header-anchor">#</a> 1.2</h3> <h3 id="_1-3-2"><a href="#_1-3-2" class="header-anchor">#</a> 1.3</h3> <h3 id="_1-2-2"><a href="#_1-2-2" class="header-anchor">#</a> 1.2</h3> <h3 id="_1-3-3"><a href="#_1-3-3" class="header-anchor">#</a> 1.3</h3> <h3 id="_1-2-3"><a href="#_1-2-3" class="header-anchor">#</a> 1.2</h3> <h3 id="_1-3-4"><a href="#_1-3-4" class="header-anchor">#</a> 1.3</h3></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/note/JavaScript/READEME.html" class="prev">
        整体介绍
      </a></span> <span class="next"><a href="/note/JavaScript/2.html">
        ES6学习笔记
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.677c9ecd.js" defer></script><script src="/assets/js/2.e8c2162f.js" defer></script><script src="/assets/js/17.f8c13808.js" defer></script>
  </body>
</html>
